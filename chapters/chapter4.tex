%!TEX root = ../dissertation.tex
%\begin{savequote}[75mm]
%\qauthor{Quoteauthor Lastname}
%\end{savequote}

\chapter{Progettazione, Codifica e Test}\label{ch:analisi_progettazione_sviluppo}

Prima di arrivare al prototipo finale ho realizzato un \textit{proof of concept} sul quale ho eseguito dei test per valutare le prestazioni che il futuro prototipo avrebbe avuto. Questo ha aiutato a fissare alcuni dei requisiti già raccolti durante l'analisi dell'applicativo precedente e di ricavarne nuovi. In seguito ho proceduto a progettare e realizzare il prototipo definitivo.

\section{Realizzazione proof of concept}

Il \acrshort{poc} doveva dimostrare che fosse possibile realizzare una versione puramente concorrente del vecchio applicativo JDI. Il \acrshort{poc} è stato realizzato in due iterazioni:

\begin{itemize}
	\item Prima iterazione: si doveva simulare il collegamento a diversi PLC. Ogni connessione simulata otteneva un proprio \textit{thread}.
	Questi effettuavano un ciclo di lettura ad intervalli specificati. La lettura era simulata con dei valori generati casualmente. I valori venivano gestiti in maniera appropriata secondo il requisito RF6;
	\item Seconda iterazione: veniva effettivamente gestito il collegamento a dei veri PLC. Su questi venivano effettuate le stesse operazioni di lettura della prima iterazione, i valori erano ora realmente prodotti dal PLC. 
\end{itemize}

\subsection{Prima iterazione}
Prima di descrivere il processo per lo sviluppo della prima iterazione di \acrshort{poc} è necessario fare dei chiarimenti su alcuni termini utilizzati in seguito:

\begin{itemize}
	\item \textit{\Gls{driver}}: Implementazione di un protocollo. Viene utilizzato per effettuare operazioni sul PLC (e.g. connessione, letture, scritture). Nella prima iterazione il \textit{\gls{driver}} non implementa alcun protocollo ma simula l'operazione di lettura;
	
	\item \textit{Engine} (o \textit{DriverEngine}): Thread che utilizza un \textit{\gls{driver}} per effettuare cicli di lettura o scrittura su PLC. Nella prima iterazione l'\textit{Engine} effettua solo cicli di  lettura;
	
	\item \textit{Tag}: rappresentazione di un'area di memoria letta dal PLC. In essa sono contenute le informazioni relative all'area di memoria rappresentata (i.e. indirizzo in memoria, il tipo del dato, permessi di accesso in lettura/scrittura) e il valore che essa assume;
	
	\item \textit{Store} (o \textit{TagStore}): oggetto che raccoglie e aggiorna i valori delle \textit{tag}.

	\item Tempo di \textit{polling} (o \textit{PollingTime}): intervallo tra un ciclo di lettura/scrittura e il successivo, spesso indicato in millisecondi (ms).
\end{itemize}

Per ogni PLC che si intende simulare viene creato un \textit{Engine} a cui viene fornito:
\begin{itemize}
	\item la configurazione delle \textit{Tag} che deve leggere;
	\item il \textit{\Gls{driver}} per simulare le letture;
	\item un tempo di \textit{polling} per ripetere il ciclo di lettura ad intervalli regolari;
	\item l'oggetto \textit{Store} a cui delega la gestione dei valori letti.
\end{itemize}

L'obiettivo principale di questa iterazione era trovare una struttura dati adatta a gestire i flussi di aggiornamento dei diversi \textit{thread}. Nello schema in figura \ref{fig:poc_1_schema} si osserva come ho voluto realizzare il \acrshort{poc}:\\



\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/poc_1_schema}
	\caption{Schema logico prima iterazione \acrshort{poc} di JDI}
	\label{fig:poc_1_schema}
\end{figure}


La scelta della struttura dati che il \textit{TagStore} utilizza per mantenere in memoria e aggiornare i valori ricavati dalle letture si è ridotta a due possibili soluzioni:
\begin{enumerate}
	\item Fornire ogni \textit{Engine} di una \textit{HashMap} e lasciare quindi che ogni \textit{thread} gestisse i propri valori. Questo avrebbe evitato accessi concorrenti alle strutture dati, rendendo più difficoltosa il reperimento di una specifica \textit{Tag};
	
	\item Utilizzare una \textit{ConcurrentHashMap}\footnote{\href{https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html}{https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html}} condivisa da tutti gli \textit{Engine}. Questo avrebbe introdotto concorrenza negli accessi alla mappa, centralizzando però tutte le \textit{tag} lette.
\end{enumerate}

Michał Siatkowski \footnote{\href{https://github.com/atais}{https://github.com/atais}} ha realizzato dei test di performance sulle due strutture dati prese in considerazione. In figura \ref{fig:performance_test_concurrenthashmap} il grafico relativo alle prestazioni dell'operazione \textit{add}. I dati interessanti per la scelta sono quelli delle due linee più in basso, ottenuti utilizzando un thread per \textit{core}\\

\clearpage

\label{fig:performance_test_concurrenthashmap}
\begin{figure}[h]
	\centering
	\includegraphics[width=1.1\textwidth]{figures/concurrenthashmap_hashmap_performance}
	\caption[Test di performance per \textit{ConcurrentHashMap}. Nelle ordinate il tempo impiegato per l'operazione, nelle ascisse il numero di elementi scritti nelle mappe.]{Test di performance per \textit{ConcurrentHashMap}. Nelle ordinate il tempo impiegato per l'operazione, nelle ascisse il numero di elementi scritti nelle mappe. (Ulteriori risultati sono disponibili su \href{https://stackoverflow.com/questions/1378310/performance-concurrenthashmap-vs-hashmap}{https://stackoverflow.com/questions/1378310/performance-concurrenthashmap-vs-hashmap})} 
\end{figure}


Nelle sue conclusioni ha evidenziato:

\begin{quote}
	When operating on ConcurrentHashMap with many threads it is similarly effective to operating on separate HashMaps for each thread. So there is no need to partition your data in different structures.
\end{quote}

Rendendo quindi non necessario in caso di \textit{multithreading} distribuire informazione su multiple strutture dati.

La scelta è quindi ricaduta sull'utilizzo di una \textit{ConcurrentHashMap} condivisa dai diversi \textit{thread}. Un ulteriore test di performance è stato realizzato e descritto in \ref{sec:benchmark}


\clearpage

\subsection{Seconda iterazione}


Un altro scoglio iniziale era certamente rappresentato dall'interazione tra il software JDI e i PLC. Dovevo infatti dimostrare di poter utilizzare il protocollo Modbus TCP/IP per effettuare le operazioni di lettura. La seconda iterazione del \acrshort{poc} prevedeva di realizzare un \textit{\gls{driver}} per il collegamento ai PLC.\\
In figura \ref{fig:poc_2_schema} lo schema per la realizzazione della seconda iterazione.
\newline



\begin{figure}[h]
	\centering
	\includegraphics[width=1.1\textwidth]{figures/poc_2_scheme.jpeg}
	\caption{Schema logico seconda iterazione \acrshort{poc} di JDI}
	\label{fig:poc_2_schema}
\end{figure}


Grazie all'analisi svolta in primo luogo sulla vecchia struttura di JDI è stato possibile individuare i componenti riutilizzabili nella nuova versione da me sviluppata.\\ 
Il componente più importante è stato il \textit{\gls{driver}}, che conteneva l'implementazione del protocollo Modbus TCP/IP. Questo presentava una comoda interfaccia effettuare le tipiche operazioni su PLC: connessione, disconnessione, lettura e scrittura.\\
La realizzazione ex novo di un \textit{\gls{driver}} avrebbe richiesto lo studio a basso livello del protocollo Modbus e Modbus TCP/IP. Il riuso in questo caso si è rivelata una scelta appropriata.
\newline

Inserire nel progetto questo componente ha avuto però dei lati negativi: 
\begin{itemize}
	\item Una parte del codice del \textit{\gls{driver}} serviva a svolgere compiti che, ai fini dello stage, non sono risultati utili; 
	\item Assieme al \textit{\gls{driver}} ho dovuto importare nel progetto le sue dipendenze. Prevalentemente librerie sviluppate da \acrshort{smi};
	\item Sono stato vincolato all'uso di alcune classi per mantenere una compatibilità; principalmente quelle relative ai tipi dei dati letti e scritti. Come specificato nei requisiti infatti, alla lettura di una certa area di memoria consegue l'interpretazione del dato con uno specifico tipo.
\end{itemize}

Queste conseguenze sono state comunque largamente colmate dalle decine di ore di lavoro risparmiate per la creazione di un \textit{\gls{driver}} per il protocollo Modbus TCP/IP.\\

\clearpage

\section{Benchmark} \label{sec:benchmark}


Come visto nella sezione precedente, per scegliere la struttura dati per la gestione dei valori letti mi sono affidato ai test eseguiti da Michał Siatkowski che confrontavano le prestazioni di \textit{HashMap} e \textit{ConcurrentHashMap} in diverse situazioni.\\
Per fondare la scelta su basi ancora più solide ho sviluppato un ulteriore \gls{benchmark} per estrarre dei dati relativi all'accesso concorrente di più \gls{thread} alla \textit{ConcurrentHashMap} condivisa dai diversi \gls{engine}. Il test utilizza la logica del \gls{poc} realizzato alla prima iterazione. Lo logica di riferimento è quindi quella rappresentata in figura \ref{fig:poc_1_schema}.

Avendo realizzato diverse versioni di \gls{benchmark} è risultato utile utilizzare il versionamento di git per fermare nel tempo le diverse versioni sviluppate, utilizzando il sistema di \textit{tagging}\footnote{Più informazioni su \href{https://git-scm.com/book/en/v2/Git-Basics-Tagging}{https://git-scm.com/book/en/v2/Git-Basics-Tagging}}. In figura \ref{fig:gitkraken_benchmark} è presente una vista del software GitKraken che mostra come ogni versione di \textit{benchmark} abbia una \textit{tag} associata.\\


\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/gitkraken_benchmark}
	\caption{Interfaccia di GitKraken che mostra come ho tenuto traccia dei diversi \textit{benchmark} effettuati}
	\label{fig:gitkraken_benchmark}
\end{figure}

Il test aveva come scopo quello di simulare la presenza di molteplici PLC che fornivano dati al sistema JDI e valutare quantitativamente la risposta dell'applicativo alle centinaia di dati da gestire concorrentemente. Di seguito viene descritto il test:\\
la simulazione prevede un numero variabile di \textit{thread} \textit{Engine} che accedono concorrentemente alla mappa, contenuta all'interno di un \textit{TagStore} condiviso, per aggiornare i valori delle \textit{Tag} generati casualmente dal \textit{Driver}.\\ 
Ogni \textit{Engine} ha nella propria configurazione 150 \textit{Tag}, corrispondenti quindi a 150 valori generati dal \textit{Driver}. \\
Vengono eseguiti dieci cicli di aggiornamento alla fine dei quali sono rilevati i tempi di esecuzione. \\
Questo \textit{benchmark} è eseguito cinque volte e viene infine fatta la media dei tempi di esecuzione rilevati. Il numero di \textit{thread} \textit{Engine} varia da 10 a 1000.\\

L'obiettivo da raggiungere era una crescita lineare dei tempi di esecuzione fino ai 100 \gls{thread}.

La tabella \ref{tab:benchmark_1} mostra i tempi di esecuzione in relazione al numero  di \gls{thread}. Il grafico in figura \ref{fig:grafico_benchmark_1} mostra i risultati.



\begin{center}
	\begin{longtable}{||c|c||} 
		\hline
		Thread & Tempo di esecuzione medio (ms) \\ [0.5ex] 
		\hline\hline
		10 & 4835 \\ 
		\hline
		20 & 4969 \\
		\hline
		30 & 5848 \\
		\hline
		40 & 5033 \\
		\hline
		50 & 5086 \\
		\hline
		60 & 5123 \\
		\hline
		70 & 5143 \\
		\hline
		80 & 5098 \\
		\hline
		90 & 5181 \\
		\hline
		100 & 5236 \\
		\hline
		200 & 6805 \\
		\hline
		400 & 12612 \\
		\hline
		800 & 24126\\
		\hline
		1000 & 29896 \\
		\hline
		\caption{Risultati benchmark per la scelta della struttura dati}
		\label{tab:benchmark_1}
	\end{longtable}
\end{center}

\clearpage

I risultati ottenuti dal \textit{benchmark} hanno superato le aspettative. I tempi di esecuzione rimangono pressoché stabili fino a 100 \textit{thread} \textit{Engine}. L'obiettivo posto inizialmente sulle prestazioni attese è quindi stato soddisfatto.


\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/benchmark_1_grafico}
	\caption{Grafico scalabilità concorrenza di \textit{ConcurrentHashMap}}
	\label{fig:grafico_benchmark_1}
\end{figure}

\clearpage

\section{Progettazione prototipo}
Per ottenere un'architettura solida e manutenibile è stato scelto di gestire separatamente le operazioni di lettura e di scrittura. Nella soluzione sviluppata \textbf{per ogni PLC} saranno istanziati quindi due \textit{thread}: 
\begin{itemize}
	\item il primo occupa di effettuare la lettura (grazie al proprio \textit{\gls{driver}}) di tutte le aree di memoria definite nel file di configurazione. Questa operazione avviene ad intervalli regolari definiti anch'essi nella configurazione. L'intervallo è chiamato tempo di \textit{\gls{polling}};
	\item il secondo rimane in attesa che avvenga una richiesta di scrittura. Quando questa avviene utilizza il proprio \textit{\gls{driver}} per completare la richiesta.
\end{itemize}

Le specifiche di un'area di memoria da leggere o scrivere sono definite \textit{TagConfiguration}. L'insieme di una \textit{TagConfiguration} e del valore letto definisce una \textit{Tag}.

L'attività di progettazione ha portato alla definizione di un'architettura composta principalmente dai componenti esposti di seguito. Dopo una breve descrizione verranno analizzati alcuni di essi in dettaglio.
 

\begin{itemize}
	\item \textit{Configurators}: gerarchia di classi che si occupano di elaborare il file JSON contenente la configurazione delle macchine. La loro interfaccia permette di creare separatamente i \textit{thread} di lettura e quelli di scrittura. Uno per ogni PLC specificato nella configurazione. In figura \ref{fig:json} un esempio del file che il sistema è in grado di elaborare;
	
	\item \textit{Engines}: contiene le classi che definiscono i \textit{task} che i \textit{thread} devono svolgere. Queste sono \textit{TagUpdater} e \textit{TagPoller}. La prima definisce il \textit{task} per la scrittura, la seconda il \textit{task} di lettura;

	\item \textit{Request\_handlers}: classi che astraggono i dettagli per portare a termine le richieste di lettura e scrittura. Vengono utilizzate da \textit{TagUpdater} e \textit{TagPoller};
	
	\item Store: Classi per la gestione dei valori letti e scritti. 
\end{itemize}

\clearpage
\begin{lstlisting}[language=json,firstnumber=1, caption={Esempio di una configurazione in formato JSON. È presente una sola macchina denominata "plc-fisico". Per questa sono definite due aree di memoria con diversi permessi.}]
{"machines": {
	"plc-fisico": {
		"driver": "driver-modbustcp",
		"settings": {
			"PollingTime": "1000",
			"Address": "10.200.200.80",
			"Port": "502",
			"unitId": "100"
		},
		"tags": {
			"counter": {
				"type": "it.smi.types.Int32",
				"address": "40017",
				"canRead": true,
				"canWrite": false
			},
			"watchdog": {
				"type": "it.smi.types.Int16",
				"address": "40020",
				"canRead": true,
				"canWrite": true
			}
		}
	}
}}
\end{lstlisting}
\label{fig:json}

\clearpage
\paragraph{Configurators}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/configurators}
	\caption{Diagramma delle classi del componente \textit{Configurators}}
	\label{fig:configurators}
\end{figure}

Il componente \textit{Configurators} racchiude le classi che effettuano le operazioni di creazione dei \textit{thread} per la lettura e per la scrittura. Utilizzano la libreria \textit{Jackson}\footnote{Ulteriori informazioni disponibili su \href{https://github.com/FasterXML/jackson}{https://github.com/FasterXML/jackson}} per processare il file JSON di configurazione.

La classe base \textit{Configuration} effettua le operazioni di basso livello con il file JSON per ottenere, per ogni PLC specificato, il \textit{\gls{driver}} adatto. Ricava poi le \textit{TagConfiguration} per ogni area di memoria interessata da lettura e scrittura.

\textit{ReadingConfiguration} grazie al lavoro svolto dalla classe padre \textit{Configuration} estrae i \textit{thread} per la lettura fornendo loro la lista di \textit{TagConfiguration} con i permessi di lettura.

\textit{WritingConfiguration} fornisce lo stesso servizio ma ricavando le configurazioni sulla base dei permessi di scrittura.\\


\begin{lstlisting}[language=java, caption={Le configurazioni delle tag da leggere per un dato PLC vengono filtrate usando gli Stream Java}]
//ReadingConfiguration
private List<TagConfiguration> filterReadableConfigurations(
		List<TagConfiguration> tagConfigurations) {
	return tagConfigurations.stream()
	.filter(TagConfiguration::canRead)
	.collect(
		Collectors.toCollection(ArrayList::new)
	);
}
\end{lstlisting}

\clearpage

\paragraph{Engines}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/engines}
	\caption{Diagramma delle classi del componente \textit{Engines}}
	\label{fig:configurators}
\end{figure}

In questo componente sono definite le classi che implementano l'interfaccia \textit{Runnable}. Rappresentano i \textit{task} che i \textit{thread} devono svolgere. Il \textit{task} definito in \textit{TagPoller} verrà svolto dai \textit{thread} di lettura. Quello in \textit{TagUpdater} da quelli di scrittura. Utilizzano la classe \textit{ConnectionHandler} per delegare la gestione della connessione con il proprio \textit{\gls{driver}}.

Osservando il metodo \textit{run} della classe \textit{TagPoller} nella figura \ref{fig:tagpoller} si può intuire il funzionamento di base che un \textit{thread} di lettura avrà. Vengono effettuate le letture verso il PLC di tutte le \textit{Tag} etichettate come "da leggere". Il \textit{thread} che sta svolgendo il \textit{task} viene mandato in \textit{sleep()} per il tempo di \textit{\gls{polling}} specificato all'interno della configurazione. Si tratta di un'esecuzione che termina solo quando il \textit{thread} corrente viene interrotto. \\

Il metodo \textit{run()} della classe \textit{TagUpdater} in figura \ref{fig:tagupdater} risulta allo stesso modo di facile comprensione. I dettagli del suo funzionamento verranno approfonditi in seguito, quando si mostrerà l'integrazione tra i componenti \textit{Store} e \textit{Engines}.\\

\clearpage
\begin{lstlisting}[language=java,caption={Metodo run() della classe TagPoller}]
//TagPoller
@Override
public void run() {
	ConnectionHandler.instantiateConnectionFor(driver, LOG_NAME, MACHINE_NAME);
	try {
		while (!Thread.interrupted()) {
			readTags();
			Thread.sleep(POLLING_TIME);
		}
	} catch (InterruptedException e) {
		Logger.log(LOG_NAME + " Thread interrupted");
	} finally {
		ConnectionHandler.interruptConnectionFor(driver, MACHINE_NAME);
		MachineStatusesRepository.communicateStatusChange(MACHINE_NAME, MachineStatusesRepository.Status.DISCONNECTED);
	}
}
\end{lstlisting}
\label{fig:tagpoller}



\begin{lstlisting}[language=java,caption={Metodo run() della classe TagUpdater}]
//TagUpdater
@Override
public void run() {
	ConnectionHandler.instantiateConnectionFor(driver, LOG_NAME);
	while (!Thread.interrupted()) {
		retrieveAndWriteTag();
	}
	Logger.log(LOG_NAME + " Thread interrupted");
	ConnectionHandler.interruptConnectionFor(driver);
}
\end{lstlisting}
\label{fig:tagupdater}

\clearpage

\paragraph{Store}

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{figures/store}
	\caption{Diagramma delle classi principali del componente \textit{Store}}
	\label{fig:store}
\end{figure}

All'interno del componente \textit{Store} sono contenute le classi che si occupano di gestire i dati da leggere e da scrivere. Queste collaborano con le classi del componente \textit{Engines}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{figures/polling_scheme}
	\caption{Schema del ciclo di \textit{polling}}
	\label{fig:polling_scheme}
\end{figure}


Per la gestione dei numerosi dati regolarmente aggiornati provenienti dai PLC è necessario appoggiarsi ad adeguati componenti che tengono traccia dei cambiamenti. Come detto nella sezione \ref{sec:benchmark}, la struttura dati di riferimento per i valori letti è una ConcurrentHashMap. 

Lo schema in figura \ref{fig:polling_scheme} mostra l'operazione di \textit{\gls{polling}} che avviene per la lettura delle \textit{Tag} M1, M2 e M3. Seguendo i passi principali evidenziali nella figura si comprende come i componenti delle due classi collaborino:
\begin{enumerate}
	\item il \textit{thread} che esegue il \textit{task} definito in \textit{TagPoller} (Engines) effettua il ciclo di lettura. Le \textit{Tag} lette vengono raccolte in una lista;
	\item la lista viene mandata a \textit{OnRamPollingTagRepository} (Store) che si occupa di aggiornare i valori contenuti nell'oggetto \textit{storedTags}.
\end{enumerate} 
Questi passi vengono eseguiti ad ogni ciclo di \textit{\gls{polling}}.\\

Per terminare la visione dell'integrazione tra i componenti \textit{Engines} e \textit{Store} viene ora descritta la gestione delle richieste di scrittura: per ottenere una bassa latenza tra il momento in cui viene richiesta una scrittura e quando viene presa in carico dal \textit{thread} di scrittura ho preso spunto dal classico \textbf{problema del produttore/consumatore}.


Il \textit{thread} di scrittura richiede al proprio oggetto \textit{OnRamTagUpdaterRepositoy} una \textit{Tag} che è in attesa di essere scritta. Il \textit{thread} svuota la coda di richieste. Se non ci sono richieste pendenti il \textit{thread} di scrittura viene messo in stato di \textit{wait}. Appena la \textit{repository} riceve una nuova richiesta di scrittura il \textit{thread} viene notificato. Questo riprenderà la sua esecuzione consumando la nuova richiesta.

Questo meccanismo è stato semplificato dalla creazione della classe \textit{TagsToWriteQueue} che ingloba un \textit{ConcurrentLinkedDeque} utilizzato per gestire le richieste per ogni \textit{thread} di scrittura. Di seguito i metodi di \textit{TagsToWriteQueue} che utilizzano \textit{wait()} e \textit{notify()} per rispettivamente fermare e riattivare il consumo delle richieste.

\begin{lstlisting}[language=java,caption={Metodi che implementano il problema produttore/consumatore per gestire le richieste di scrittura}]
//TagsToWriteQueue
synchronized void addTagPair(String tagNameToInsert, 
				AbstractValue newValue) {
	tagsQueue.add(new Pair<>(tagNameToInsert, newValue));
	notify();
}
synchronized Pair<String, AbstractValue> popTagPair() {
	if (tagsQueue.isEmpty()) {
		try {
			wait();
		} catch (InterruptedException e) {
			Logger.log(LOG_NAME + "Interrupted during wait");
			Thread.currentThread().interrupt();
		}
	}
	return tagsQueue.poll();
}
\end{lstlisting}


\section{Verifica e validazione}

I processi di verifica e validazione si occupano di controllare che il software sviluppato rispetti i requisiti definiti da chi ha richiesto il software. Questi controlli iniziano appena sono disponibili i primi requisiti e continuano per tutta la durata del processo di sviluppo.

\textit{Barry Boehm} espresse in breve la differenza tra verifica e validazione nel seguente modo:
\begin{quote}
	\begin{itemize}
		\item Validation: Are we building the right product?
		\item Verification: Are we building the product right?
	\end{itemize}
\end{quote}

L'obiettivo della verifica è controllare che il software soddisfi i requisiti funzionali e non funzionali definiti durante l'attività di analisi.

La validazione riguarda invece un punto di vista più ampio: il suo scopo è di assicurarsi che il software soddisfi le aspettative del cliente. Risulta essenziale poiché non sempre i bisogni di chi ha richiesto il software sono perfettamente rispecchiati nell'analisi dei requisiti.\\



Per quanto riguarda la verifica, JDI è stato sottoposto ad analisi statica e dinamica
\begin{itemize}
	\item Analisi statica: non richiede l'esecuzione del software che si sta mettendo alla prova. Può evidenziare numerosi problemi nel codice sorgente prima ancora di eseguire test di unità;
	\item Analisi dinamica: prevede l'esecuzione del codice. Verifica la presenza di difetti nel prodotto. 
\end{itemize}


Gli strumenti utilizzati per effettuare l'analisi statica erano integrati nell'IDE Intellij. È stato configurato per rilevare probabili \textit{bug}, aree del codice non raggiunte e problemi di \textit{performance}. Sono inoltre state utilizzate le configurazioni di \acrshort{smi} per verificare le linee guida per l'indentazione e l'organizzazione del codice.\\


Per effettuare analisi dinamica invece sono stati implementati test di unità con il \textit{framework} JUnit per rilevare la presenza di difetti nelle classi più delicate:
\begin{itemize}
	\item \textit{TagUpdaterRepository};
	\item \textit{TagsToWriteQueue}.
\end{itemize}
Per questi due moduli è stato utilizzato il \acrfull{tdd}. Una pratica che prevede di scrivere codice solamente per far passare un test che fallisce. I passi seguiti per lo sviluppo dei moduli è sono stati i seguenti:
\begin{enumerate}
	\item pensare ad un test per verificare una funzionalità del modulo;
	\item eseguire il test. Inizialmente questo fallirà;
	\item scrivere il codice per soddisfare il test scritto;
	\item verificare che il codice non abbia introdotto regressioni. I test scritti precedente devono passare;
	\item riorganizzare il codice scritto;
	\item ripetere i passi precedenti.
\end{enumerate}

Per rispettare i vicoli sul consumo della memoria sono stati eseguiti test di \textit{performance} che prevedevano l'esecuzione del sistema in condizioni simili di stress. I dati rilevato sono stati analizzati e approvati dal tutor \acrshort{smi}. I risultati si sono attestati al di sotto dei 2GB vincolati dall'analisi.\\

La validazione del sistema ha accertato che il software prodotto rispettasse i requisiti elaborati da \acrshort{smi}. Per valutare oggettivamente il prodotto sviluppato si sono svolte numerose riunioni in presenza del tutor Alex Beggiato e dei membri del team di sviluppo JMES. L'esito è stato estremamente positivo, avendo raggiunto tutti gli obiettivi posti a inizio stage e i requisiti raccolti durante l'attività di analisi.


