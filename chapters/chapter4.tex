%!TEX root = ../dissertation.tex
%\begin{savequote}[75mm]
%\qauthor{Quoteauthor Lastname}
%\end{savequote}

\chapter{Progettazione, Codifica e Test}\label{ch:analisi_progettazione_sviluppo}

Prima di arrivare al prototipo finale ho realizzato un \textit{proof of concept} sul quale ho eseguito dei test per valutare le prestazioni che il futuro prototipo avrebbe avuto. Questo ha aiutato a fissare alcuni dei requisiti già raccolti durante l'analisi dell'applicativo precedente e di ricavarne nuovi. In seguito ho proceduto a progettare e realizzare il prototipo definitivo.

\section{Realizzazione proof of concept}

Il \acrshort{poc} doveva dimostrare che fosse possibile realizzare una versione puramente concorrente del vecchio applicativo JDI. Il \acrshort{poc} è stato realizzato in due iterazioni:

\begin{itemize}
	\item Prima iterazione: si doveva simulare il collegamento a diversi PLC. Ogni connessione simulata otteneva un proprio \textit{thread}.
	Questi effettuavano un ciclo di lettura ad intervalli specificati. La lettura era simulata con dei valori generati casualmente. I valori venivano gestiti in maniera appropriata secondo il requisito RF6;
	\item Seconda iterazione: veniva effettivamente gestito il collegamento a dei veri PLC. Su questi venivano effettuate le stesse operazioni di lettura della prima iterazione, i valori erano ora realmente prodotti dal PLC. 
\end{itemize}

\subsection{Prima iterazione}\label{subsec:prima_iterazione}
Prima di descrivere il processo per lo sviluppo della prima iterazione di \acrshort{poc} è necessario fare dei chiarimenti su alcuni termini utilizzati in seguito:

\begin{itemize}
	\item \textit{\Gls{driver}}: implementazione di un protocollo. Viene utilizzato per effettuare operazioni sul PLC (e.g. connessione, letture, scritture). Nella prima iterazione il \textit{\gls{driver}} non implementa alcun protocollo ma simula l'operazione di lettura;
	
	\item \textit{Engine} (o \textit{DriverEngine}): \gls{thread} che utilizza un \textit{\gls{driver}} per effettuare cicli di lettura su PLC a intervalli regolari;
	
	\item \textit{Tag}: rappresentazione di un'area di memoria letta dal PLC. In essa sono contenute le informazioni relative all'area di memoria rappresentata (vale a dire indirizzo in memoria, il tipo del dato, permessi di accesso in lettura/scrittura) e il valore che essa assume;
	
	\item \textit{Store} (o \textit{TagStore}): oggetto che raccoglie e aggiorna i valori delle \textit{tag};

	\item Tempo di \textit{polling} (o \textit{PollingTime}): intervallo tra un ciclo di lettura e il successivo, spesso indicato in millisecondi (ms).
\end{itemize}

Per ogni PLC che si intende simulare viene creato un \textit{Engine} a cui viene fornito:
\begin{itemize}
	\item La configurazione delle \textit{Tag} che deve leggere;
	\item Il \textit{\Gls{driver}} per simulare le letture;
	\item Un tempo di \textit{polling} per ripetere il ciclo di lettura ad intervalli regolari;
	\item L'oggetto \textit{Store} a cui delega la gestione dei valori letti.
\end{itemize}

L'obiettivo principale di questa iterazione era trovare una struttura dati adatta a gestire i flussi di aggiornamento dei diversi \textit{thread}. Nello schema in figura \ref{fig:poc_1_schema} si osserva come ho voluto realizzare il \acrshort{poc}:\\



\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/poc_1_schema}
	\caption{Schema logico prima iterazione \acrshort{poc} di JDI}
	\label{fig:poc_1_schema}
\end{figure}


La scelta della struttura dati che il \textit{TagStore} utilizza per mantenere in memoria e aggiornare i valori ricavati dalle letture si è ridotta a due possibili soluzioni:
\begin{enumerate}
	\item Fornire ogni \textit{Engine} di una \textit{HashMap} e lasciare quindi che ogni \textit{thread} gestisse i propri valori. Questo avrebbe evitato accessi concorrenti alle strutture dati, rendendo più difficoltosa il reperimento di una specifica \textit{Tag};
	
	\item Utilizzare una \textit{ConcurrentHashMap}\footnote{\href{https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html}{https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html}} condivisa da tutti gli \textit{Engine}. Questo avrebbe introdotto concorrenza negli accessi alla mappa, centralizzando però tutte le \textit{tag} lette.
\end{enumerate}

Michał Siatkowski \footnote{\href{https://github.com/atais}{https://github.com/atais}} ha realizzato dei test di performance sulle due strutture dati prese in considerazione. In figura \ref{fig:performance_test_concurrenthashmap} il grafico relativo alle prestazioni dell'operazione \textit{add}. I dati interessanti per la scelta sono quelli delle due linee più in basso, ottenuti utilizzando un thread per \textit{core}\\

\clearpage

\label{fig:performance_test_concurrenthashmap}
\begin{figure}[h]
	\centering
	\includegraphics[width=1.1\textwidth]{figures/concurrenthashmap_hashmap_performance}
	\caption[Test di performance per \textit{ConcurrentHashMap}. Nelle ordinate il tempo impiegato per l'operazione, nelle ascisse il numero di elementi scritti nelle mappe.]{Test di performance per \textit{ConcurrentHashMap}. Nelle ordinate il tempo impiegato per l'operazione, nelle ascisse il numero di elementi scritti nelle mappe. (Ulteriori risultati sono disponibili su \href{https://stackoverflow.com/questions/1378310/performance-concurrenthashmap-vs-hashmap}{https://stackoverflow.com/questions/1378310/performance-concurrenthashmap-vs-hashmap})} 
\end{figure}


Nelle sue conclusioni ha evidenziato:

\begin{quote}
	When operating on ConcurrentHashMap with many threads it is similarly effective to operating on separate HashMaps for each thread. So there is no need to partition your data in different structures.
\end{quote}

Rendendo quindi non necessario in caso di \textit{multithreading} distribuire informazione su multiple strutture dati.

La scelta è quindi ricaduta sull'utilizzo di una \textit{ConcurrentHashMap} condivisa dai diversi \textit{thread}. Un ulteriore test di performance è stato realizzato e descritto in \ref{sec:benchmark}


\clearpage

\subsection{Seconda iterazione}


Un altro scoglio iniziale era certamente rappresentato dall'interazione tra il software JDI e i PLC. Dovevo infatti dimostrare di poter utilizzare il protocollo Modbus TCP/IP per effettuare le operazioni di lettura. La seconda iterazione del \acrshort{poc} prevedeva di realizzare un \textit{\gls{driver}} per il collegamento ai PLC.\\
In figura \ref{fig:poc_2_schema} lo schema per la realizzazione della seconda iterazione.
\newline



\begin{figure}[h]
	\centering
	\includegraphics[width=1.1\textwidth]{figures/poc_2_scheme.jpeg}
	\caption{Schema logico seconda iterazione \acrshort{poc} di JDI}
	\label{fig:poc_2_schema}
\end{figure}


Grazie all'analisi svolta in primo luogo sulla vecchia struttura di JDI è stato possibile individuare i componenti riutilizzabili nella nuova versione da me sviluppata.\\ 
Il componente più importante è stato il \textit{\gls{driver}}, che conteneva l'implementazione del protocollo Modbus TCP/IP. Questo presentava una comoda interfaccia effettuare le tipiche operazioni su PLC: connessione, disconnessione, lettura e scrittura.\\
La realizzazione ex novo di un \textit{\gls{driver}} avrebbe richiesto lo studio a basso livello del protocollo Modbus e Modbus TCP/IP. Il riuso in questo caso si è rivelata una scelta appropriata.
\newline

Inserire nel progetto questo componente ha avuto però dei lati negativi: 
\begin{itemize}
	\item Una parte del codice del \textit{\gls{driver}} serviva a svolgere compiti che, ai fini dello stage, non sono risultati utili; 
	\item Assieme al \textit{\gls{driver}} ho dovuto importare nel progetto le sue dipendenze. Prevalentemente librerie sviluppate da \acrshort{smi};
	\item Sono stato vincolato all'uso di alcune classi per mantenere una compatibilità; principalmente quelle relative ai tipi dei dati letti e scritti. Come specificato nei requisiti infatti, alla lettura di una certa area di memoria consegue l'interpretazione del dato con uno specifico tipo.
\end{itemize}

Queste conseguenze sono state comunque largamente colmate dalle decine di ore di lavoro risparmiate per la creazione di un \textit{\gls{driver}} per il protocollo Modbus TCP/IP.\\

\clearpage

\section{Benchmark} \label{sec:benchmark}


Come visto nella sezione precedente, per scegliere la struttura dati per la gestione dei valori letti mi sono affidato ai test eseguiti da Michał Siatkowski che confrontavano le prestazioni di \textit{HashMap} e \textit{ConcurrentHashMap} in diverse situazioni.\\
Per fondare la scelta su basi ancora più solide ho sviluppato un ulteriore \gls{benchmark} per estrarre dei dati relativi all'accesso concorrente di più \gls{thread} alla \textit{ConcurrentHashMap} condivisa dai diversi \gls{engine}. Il test utilizza la logica del \gls{poc} realizzato alla prima iterazione. Lo logica di riferimento è quindi quella rappresentata in figura \ref{fig:poc_1_schema}.

Avendo realizzato diverse versioni di \gls{benchmark} è risultato utile utilizzare il versionamento di git per fermare nel tempo le diverse versioni sviluppate, utilizzando il sistema di \textit{tagging}\footnote{Più informazioni su \href{https://git-scm.com/book/en/v2/Git-Basics-Tagging}{https://git-scm.com/book/en/v2/Git-Basics-Tagging}}. In figura \ref{fig:gitkraken_benchmark} è presente una vista del software GitKraken che mostra come ogni versione di \textit{benchmark} abbia una \textit{tag} associata.\\


\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/gitkraken_benchmark}
	\caption{Interfaccia di GitKraken che mostra come ho tenuto traccia dei diversi \textit{benchmark} effettuati}
	\label{fig:gitkraken_benchmark}
\end{figure}

Il test aveva come scopo quello di simulare la presenza di molteplici PLC che fornivano dati al sistema JDI e valutare quantitativamente la risposta dell'applicativo alle centinaia di dati da gestire concorrentemente. Di seguito viene descritto il test:\\
la simulazione prevede un numero variabile di \textit{thread} \textit{Engine} che accedono concorrentemente alla mappa, contenuta all'interno di un \textit{TagStore} condiviso, per aggiornare i valori delle \textit{Tag} generati casualmente dal \textit{Driver}.\\ 
Ogni \textit{Engine} ha nella propria configurazione 150 \textit{Tag}, corrispondenti quindi a 150 valori generati dal \textit{Driver}. \\
Vengono eseguiti dieci cicli di aggiornamento alla fine dei quali sono rilevati i tempi di esecuzione. \\
Questo \textit{benchmark} è eseguito cinque volte e viene infine fatta la media dei tempi di esecuzione rilevati. Il numero di \textit{thread} \textit{Engine} varia da 10 a 1000.\\

L'obiettivo da raggiungere era una crescita lineare dei tempi di esecuzione fino ai 100 \gls{thread}.

La tabella \ref{tab:benchmark_1} mostra i tempi di esecuzione in relazione al numero  di \gls{thread}. Il grafico in figura \ref{fig:grafico_benchmark_1} mostra i risultati.



\begin{center}
	\begin{longtable}{||c|c||} 
		\hline
		Thread & Tempo di esecuzione medio (ms) \\ [0.5ex] 
		\hline\hline
		10 & 4835 \\ 
		\hline
		20 & 4969 \\
		\hline
		30 & 5848 \\
		\hline
		40 & 5033 \\
		\hline
		50 & 5086 \\
		\hline
		60 & 5123 \\
		\hline
		70 & 5143 \\
		\hline
		80 & 5098 \\
		\hline
		90 & 5181 \\
		\hline
		100 & 5236 \\
		\hline
		200 & 6805 \\
		\hline
		400 & 12612 \\
		\hline
		800 & 24126\\
		\hline
		1000 & 29896 \\
		\hline
		\caption{Risultati benchmark per la scelta della struttura dati}
		\label{tab:benchmark_1}
	\end{longtable}
\end{center}

\clearpage

I risultati ottenuti dal \textit{benchmark} hanno superato le aspettative. I tempi di esecuzione rimangono pressoché stabili fino a 100 \textit{thread} \textit{Engine}. L'obiettivo posto inizialmente sulle prestazioni attese è quindi stato soddisfatto.


\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/benchmark_1_grafico}
	\caption{Grafico scalabilità concorrenza di \textit{ConcurrentHashMap}}
	\label{fig:grafico_benchmark_1}
\end{figure}

\clearpage

\section{Progettazione prototipo}
Per comodità riporto i termini già definiti in \ref{subsec:prima_iterazione} aggiornati per adattarsi al glossario del prototipo:
\begin{itemize}
	\item \Gls{driver}: implementazione di un protocollo. Viene utilizzato per effettuare operazioni sul PLC (e.g. connessione, letture, scritture). Il protocollo implementato dai \gls{driver}, quando non specificato, è Modbus TCP/IP;
	
	\item \Gls{tagpoller}: componente che utilizza il \gls{driver} per effettuare cicli di lettura su PLC a intervalli regolari. Un \gls{tagpoller} detiene la configurazione del PLC associato per conoscere le aree di memoria da leggere;
	
	\item \Gls{tagupdater}: componente che utilizza il \gls{driver} per effettuare la scrittura su PLC quando richiesto;

	\item \gls{tagconfiguration}: rappresentazione dell'area di memoria di un PLC. In essa sono contenute le informazioni relative all'area di memoria rappresentata: indirizzo in memoria, tipo del dato, permessi di accesso in lettura/scrittura;

	\item \Gls{tag}: insieme di \gls{tagconfiguration} e il valore che essa assume (se si tratta di un valore letto) o che deve assumere (se di tratta di un valore da scrivere);
	
	\item \gls{configurator}: componente che estrae dal file di configurazione in formato JSON le informazioni necessarie a creare ed avviare i componenti necessari al corretto funzionamento del sistema;
	
	\item \Gls{pollingtagrepository}: componente che raccoglie e mantiene aggiornati i valori delle \gls{tag} lette. Viene utilizzato dai \gls{tagpoller} per delegare la gestione dei dati letti;
	
	\item \gls{tagupdaterrepository}: componente che gestisce le richieste di scrittura di una specifica \gls{tag}. Fornisce ad ogni \gls{tagupdater} i dati necessari per effettuare le scritture;
	
	\item Tempo di \textit{polling} (o \textit{PollingTime}): intervallo tra un ciclo di lettura e il successivo, spesso indicato in millisecondi (ms).
\end{itemize}

%Per una lettura più chiara della seguente sezione si faccia riferimento ai termini definiti in \ref{subsec:prima_iterazione}.\\
\clearpage

L'architettura ottenuta dal prototipo doveva rappresentare una solida base per permettere al team JMES di realizzare, in seguito al mio stage, un sostituto completo per la versione precedente di JDI.\\
Per ottenere un'architettura solida e manutenibile ho scelto di gestire separatamente le operazioni di lettura e scrittura. Nella soluzione sviluppata, per ogni PLC saranno utilizzati due componenti: \gls{tagpoller} e \gls{tagupdater}.
\begin{itemize}
	\item Il primo si occupa di effettuare la lettura (grazie al proprio \textit{\gls{driver}}) di tutte le aree di memoria definite nel file di configurazione (queste sono le \gls{tag}). Questa operazione avviene ad intervalli regolari definiti anch'essi nella configurazione. L'intervallo è il tempo di \gls{polling};
	\item Il secondo si affida al \gls{tagupdaterrepository} per consumare la coda di richieste di scrittura che sono a lui indirizzate.
\end{itemize}

I componenti già in parte descritti nel glossario a inizio sezione e le loro interazioni sono rappresentati nell'architettura in seguito riportata.\\

\begin{figure}[h]
	\centering
	\includegraphics[width=1.1\textwidth]{figures/architettura}
	\caption{Schema architettura JDI}
	\label{fig:architettura_jdi}
\end{figure}

Nel seguito, seguendo un approccio \textit{top-down}, verranno analizzate le componenti principali dell'architettura presentata.
%L'attività di progettazione ha portato alla definizione di un'architettura composta principalmente dai componenti esposti di seguito. Dopo una breve descrizione verranno analizzati alcuni di essi in dettaglio.
 

%\begin{itemize}
%	\item \textit{Configurators}: gerarchia di classi che si occupano di elaborare il file JSON contenente la configurazione delle macchine. La loro interfaccia permette di creare separatamente i \textit{thread} di lettura e quelli di scrittura. Uno per ogni PLC specificato nella configurazione. In figura \ref{fig:json} un esempio del file che il sistema è in grado di elaborare;
%	
%	\item \textit{Engines}: contiene le classi che definiscono i \textit{task} che i \textit{thread} devono svolgere. Queste sono \textit{TagUpdater} e \textit{TagPoller}. La prima definisce il \textit{task} per la scrittura, la seconda il \textit{task} di lettura;
%
%	\item \textit{Request\_handlers}: classi che astraggono i dettagli per portare a termine le richieste di lettura e scrittura. Vengono utilizzate da \textit{TagUpdater} e \textit{TagPoller};
%	
%	\item Store: Classi per la gestione dei valori letti e scritti. 
%\end{itemize}
%
%\clearpage


\clearpage

\subsection{File di configurazione}
Verrà di seguito descritto il formato del file di configurazione utilizzato per definire con quali PLC JDI deve effettuare il collegamento e per ognuno le aree di memoria interessate dalle operazioni di lettura e scrittura.\\

Il livello più alto è il PLC. Per questo vengono definiti:
\begin{itemize}
	\item Impostazioni generali della macchina: Indirizzo IP, porta, identificativo univoco macchina e tempo di \gls{polling};
	\item Elenco delle \gls{tag}. Per ognuna viene fornito: tipo del dato, indirizzo in memoria, permesso di lettura/scrittura. Per ogni PLC possono essere definite molteplici \gls{tag}. Queste vengono identificate dalla stringa nome-macchina.nome-tag. 
\end{itemize}

In un file di configurazione possono essere presenti diverse definizioni di PLC, identificate univocamente dal nome.\\
Nel listato in figura \ref{lst:json} un esempio di file di configurazione con un solo PLC definito. Le due aree di memoria definite sono identificabili dalle stringhe \textit{plc-taglio-laser.counter} e \textit{plc-taglio-laser.watchdog}.

\clearpage

\begin{lstlisting}[language=json,firstnumber=1, caption={Esempio di una configurazione in formato JSON. È presente una sola macchina denominata "plc-fisico". Per questa sono definite due aree di memoria con diversi permessi.},label={lst:json}]
{"machines": {
  "plc-taglio-laser": {
    "settings": {
      "PollingTime": "1000",
      "Address": "10.200.200.80",
      "Port": "502",
      "unitId": "100"
    },
    "tags": {
      "counter": {
        "type": "it.smi.types.Int32",
        "address": "40017",
        "canRead": true,
        "canWrite": false
      },
      "watchdog": {
        "type": "it.smi.types.Int16",
        "address": "40020",
        "canRead": true,
        "canWrite": true
      }
    }
  }
}}
\end{lstlisting}

\clearpage

\subsection{Analisi del file di configurazione}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/configurators}
	\caption{Diagramma delle classi del componente \gls{configurator}}
	\label{fig:configurators}
\end{figure}

Il componente \gls{configurator} racchiude le classi che effettuano le operazioni di creazione dei \textit{thread} per la lettura e per la scrittura, rappresentati rispettivamente in \gls{tagpoller} e \gls{tagupdater}. Utilizzano la libreria \textit{Jackson}\footnote{Ulteriori informazioni disponibili su \href{https://github.com/FasterXML/jackson}{https://github.com/FasterXML/jackson}} per processare il file JSON di configurazione. Nella pagina seguente viene raffigurato il formato del file di configurazione.

La classe base \textit{Configuration} effettua le operazioni di basso livello con la configurazione  caricata da \textit{file system} per ottenere, per ogni PLC specificato, il \textit{\gls{driver}} adatto. Ricava poi le \textit{TagConfiguration} per ogni area di memoria interessata da lettura e scrittura.

\textit{ReadingConfiguration} grazie al lavoro svolto dalla classe padre \textit{Configuration} estrae i \textit{thread} per la lettura fornendo loro la lista di \textit{TagConfiguration} con i permessi di lettura.

\textit{WritingConfiguration} fornisce lo stesso servizio ma ricavando le configurazioni sulla base dei permessi di scrittura.


\begin{lstlisting}[language=java, caption={Le configurazioni delle tag da leggere per un dato PLC vengono filtrate usando gli Stream Java}]
//ReadingConfiguration.java
private List<TagConfiguration> filterReadableConfigurations(
		List<TagConfiguration> tagConfigurations) {
	return tagConfigurations.stream()
	.filter(TagConfiguration::canRead)
	.collect(
		Collectors.toCollection(ArrayList::new)
	);
}
\end{lstlisting}





\clearpage

\subsection{Lettura}

\gls{tagpoller} è una classe che estende l'interfaccia \textit{Runnable}. Effettua la lettura di tutte le \gls{tag} di uno specifico PLC definite nella configurazione. Questa operazione avviene ad intervalli regolari detti cicli di \gls{polling}.\\
Rappresenta il \textit{task} che il \textit{thread} di lettura svolge.\\ 
Come detto, ad ogni PLC definito nella configurazione corrispondono un \textit{thread} di lettura e uno di scrittura. Saranno istanziati quindi $n$ \gls{tagpoller}, con $n$ il numero di PLC nella configurazione.\\

Il funzionamento di \gls{tagpoller} è semplice: ad ogni ciclo utilizza la propria istanza di \gls{driver} per richiedere al PLC i valori di tutte le \gls{tag} specificate nella configurazione di \gls{tagpoller}. Questa configurazione viene fornita da \textit{ReadingConfiguration} alla creazione del \gls{thread}. I nuovi valori delle \gls{tag} vengono inviati alla \textit{repository} condivisa tra i \gls{thread} di lettura che si occupa di aggiornare i valori precedentemente letti.

Nel metodo \textit{run} della classe \gls{tagpoller} nel listato in \ref{fig:tagpoller} viene descritto ad alto livello il comportamento del \gls{thread} di lettura. Vengono effettuate le letture verso il PLC di tutte le \textit{Tag} etichettate come "da leggere". Il \textit{thread} che sta svolgendo il \textit{task} viene mandato in \textit{sleep()} per il tempo di \textit{\gls{polling}} specificato all'interno della configurazione. Si tratta di un'esecuzione che termina solo quando il \textit{thread} corrente viene interrotto in caso di errore. \\
\newline
\begin{figure}[h]
	\setlength{\belowcaptionskip}{15pt}
	\centering
	\includegraphics[width=0.8\textwidth]{figures/engines}
	\caption{Diagramma delle classi del componente che contiene \textit{TagPoller} e \textit{TagUpdater}}
	\label{fig:configurators}
\end{figure}


\clearpage

\subsection{Scrittura}
\gls{tagupdater} è una classe che estende l'interfaccia \textit{Runnable}. Si occupa di portare a termine le richieste di scrittura accumulare in \gls{tagupdaterrepository}. Rappresenta il \textit{task} che il \gls{thread} di scrittura svolge.\\ 
Anche in questo caso per ogni PLC presente nella configurazione viene istanziato un \textit{thread} di scrittura.\\

Un requisito fondamentale che \gls{tagupdater} soddisfa è la reattività alle richieste di scrittura. È importante infatti che le richieste inserite nella coda dedicate a ciascun \textit{thread}, contenute in \gls{tagupdaterrepository}, vengano elaborate nel più breve tempo possibile.\\
Per questo il ciclo del \textit{task} di scrittura consiste in una continua richiesta per l'ottenimento di una \gls{tag} da scrivere. Il metodo \textit{run()} del \textit{task} è visibile nel listato in \ref{fig:tagupdater}.\\

Per rendere efficiente la gestione delle richieste, tra \gls{tagupdater} e \gls{pollingtagrepository} avviene una sincronizzazione sulla coda prendendo spunto dal classico problema del produttore-consumatore\footnote{Più informazioni disponibili su \href{https://en.wikipedia.org/wiki/Producer\%E2\%80\%93consumer\_problem}{https://en.wikipedia.org/wiki/Producer\%E2\%80\%93consumer\_problem}}. Questo meccanismo verrà approfondito in \ref{subsec:scrittura}, dopo aver descritto la gestione delle richieste di scrittura.\\

\begin{lstlisting}[language=java,caption={Metodo run() della classe TagUpdater},label={fig:tagupdater}]
//TagUpdater
@Override
public void run() {
ConnectionHandler.instantiateConnectionFor(driver, LOG_NAME);
while (!Thread.interrupted()) {
retrieveAndWriteTag();
}
Logger.log(LOG_NAME + " Thread interrupted");
ConnectionHandler.interruptConnectionFor(driver);
}
\end{lstlisting}

\clearpage

\begin{lstlisting}[language=java,caption={Metodo run() della classe TagPoller},label={fig:tagpoller}]
//TagPoller
@Override
public void run() {
	ConnectionHandler.instantiateConnectionFor(driver, LOG_NAME, MACHINE_NAME);
	try {
		while (!Thread.interrupted()) {
			readTags();
			Thread.sleep(POLLING_TIME);
		}
	} catch (InterruptedException e) {
		Logger.log(LOG_NAME + " Thread interrupted");
	} finally {
		ConnectionHandler.interruptConnectionFor(driver, MACHINE_NAME);
		MachineStatusesRepository.communicateStatusChange(MACHINE_NAME, MachineStatusesRepository.Status.DISCONNECTED);
	}
}
\end{lstlisting}




\clearpage


\subsection{Gestione valori letti}
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{figures/store}
	\caption{Diagramma delle classi principali del componente contenente le \textit{repository}}
	\label{fig:store}
\end{figure}



\clearpage








\subsection{Gestione richieste di scrittura}\label{subsec:scrittura}



%All'interno del componente \textit{Store} sono contenute le classi che si occupano di gestire i dati da leggere e da scrivere. Queste collaborano con le classi del componente \textit{Engines}.

%\begin{figure}[h]
%	\centering
%	\includegraphics[width=0.7\textwidth]{figures/polling_scheme}
%	\caption{Schema del ciclo di \textit{polling}}
%	\label{fig:polling_scheme}
%\end{figure}

\textit{Spiegazione della gestione richieste di scrittura...}\\
%Per terminare la visione dell'integrazione tra i componenti \textit{Engines} e \textit{Store} viene ora descritta la gestione delle richieste di scrittura: per ottenere una bassa latenza tra il momento in cui viene richiesta una scrittura e quando viene presa in carico dal \textit{thread} di scrittura ho preso spunto dal classico \textbf{problema del produttore/consumatore}.


Il \textit{thread} di scrittura richiede al proprio oggetto \textit{OnRamTagUpdaterRepositoy} una \textit{Tag} che è in attesa di essere scritta. Il \textit{thread} svuota la coda di richieste. Se non ci sono richieste pendenti il \textit{thread} di scrittura viene messo in stato di \textit{wait}. Appena la \textit{repository} riceve una nuova richiesta di scrittura il \textit{thread} viene notificato. Questo riprenderà la sua esecuzione consumando la nuova richiesta.

Questo meccanismo è stato semplificato dalla creazione della classe \textit{TagsToWriteQueue} che ingloba un \textit{ConcurrentLinkedDeque} utilizzato per gestire le richieste per ogni \textit{thread} di scrittura. Di seguito i metodi di \textit{TagsToWriteQueue} che utilizzano \textit{wait()} e \textit{notify()} per rispettivamente fermare e riattivare il consumo delle richieste.\\


\textit{Aggiungere diagramma di sequenza per il funzionamento di wait/notify.}\\

\begin{lstlisting}[language=java,caption={Metodi che implementano il problema produttore/consumatore per gestire le richieste di scrittura}]
//TagsToWriteQueue
synchronized void addTagPair(String tagNameToInsert, 
				AbstractValue newValue) {
	tagsQueue.add(new Pair<>(tagNameToInsert, newValue));
	notify();
}
synchronized Pair<String, AbstractValue> popTagPair() {
	if (tagsQueue.isEmpty()) {
		try {
			wait();
		} catch (InterruptedException e) {
			Logger.log(LOG_NAME + "Interrupted during wait");
			Thread.currentThread().interrupt();
		}
	}
	return tagsQueue.poll();
}
\end{lstlisting}

\clearpage

\section{Verifica e validazione}

I processi di verifica e validazione si occupano di controllare che il software sviluppato rispetti i requisiti definiti da chi ha richiesto il software. Questi controlli iniziano appena sono disponibili i primi requisiti e continuano per tutta la durata del processo di sviluppo.

\textit{Barry Boehm} espresse in breve la differenza tra verifica e validazione nel seguente modo:
\begin{quote}
	\begin{itemize}
		\item Validation: Are we building the right product?
		\item Verification: Are we building the product right?
	\end{itemize}
\end{quote}

L'obiettivo della verifica è controllare che il software soddisfi i requisiti funzionali e non funzionali definiti durante l'attività di analisi.

La validazione riguarda invece un punto di vista più ampio: il suo scopo è di assicurarsi che il software soddisfi le aspettative del cliente. Risulta essenziale poiché non sempre i bisogni di chi ha richiesto il software sono perfettamente rispecchiati nell'analisi dei requisiti.\\



Per quanto riguarda la verifica, JDI è stato sottoposto ad analisi statica e dinamica
\begin{itemize}
	\item Analisi statica: non richiede l'esecuzione del software che si sta mettendo alla prova. Può evidenziare numerosi problemi nel codice sorgente prima ancora di eseguire test di unità;
	\item Analisi dinamica: prevede l'esecuzione del codice. Verifica la presenza di difetti nel prodotto. 
\end{itemize}


Gli strumenti utilizzati per effettuare l'analisi statica erano integrati nell'IDE Intellij. È stato configurato per rilevare probabili \textit{bug}, aree del codice non raggiunte e problemi di \textit{performance}. Sono inoltre state utilizzate le configurazioni di \acrshort{smi} per verificare le linee guida per l'indentazione e l'organizzazione del codice.\\


Per effettuare analisi dinamica invece sono stati implementati test di unità con il \textit{framework} JUnit per rilevare la presenza di difetti nelle classi più delicate:
\begin{itemize}
	\item \textit{TagUpdaterRepository};
	\item \textit{TagsToWriteQueue}.
\end{itemize}
Per questi due moduli è stato utilizzato il \acrfull{tdd}. Una pratica che prevede di scrivere codice solamente per far passare un test che fallisce. I passi seguiti per lo sviluppo dei moduli è sono stati i seguenti:
\begin{enumerate}
	\item pensare ad un test per verificare una funzionalità del modulo;
	\item eseguire il test. Inizialmente questo fallirà;
	\item scrivere il codice per soddisfare il test scritto;
	\item verificare che il codice non abbia introdotto regressioni. I test scritti precedente devono passare;
	\item riorganizzare il codice scritto;
	\item ripetere i passi precedenti.
\end{enumerate}

Per rispettare i vicoli sul consumo della memoria sono stati eseguiti test di \textit{performance} che prevedevano l'esecuzione del sistema in condizioni simili di stress. I dati rilevato sono stati analizzati e approvati dal tutor \acrshort{smi}. I risultati si sono attestati al di sotto dei 2GB vincolati dall'analisi.\\

La validazione del sistema ha accertato che il software prodotto rispettasse i requisiti elaborati da \acrshort{smi}. Per valutare oggettivamente il prodotto sviluppato si sono svolte numerose riunioni in presenza del tutor Alex Beggiato e dei membri del team di sviluppo JMES. L'esito è stato estremamente positivo, avendo raggiunto tutti gli obiettivi posti a inizio stage e i requisiti raccolti durante l'attività di analisi.


